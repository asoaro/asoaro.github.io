import{_ as s,a as r,b as d,c as i,d as c}from"./Vue2生命周期完整图解-ecfe803f.js";import{_ as l,V as p,W as h,Y as u,Z as e,$ as n,X as o,a0 as a,B as g}from"./framework-73f3449e.js";const _={},f=e("h1",{id:"详解-vue2-组件生命周期",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#详解-vue2-组件生命周期","aria-hidden":"true"},"#"),n(" 详解 Vue2 组件生命周期")],-1),b=e("h2",{id:"概述",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#概述","aria-hidden":"true"},"#"),n(" 概述")],-1),v=e("p",null,[n("在 Vue 中，一个组件本质上是一个拥有"),e("strong",null,"预定义选项"),n("的 Vue 实例对象，而组件生命周期（Life Cycle），就是指一个 Vue 实例被"),e("strong",null,"创建、运行、销毁"),n("的整个阶段")],-1),m=a('<h2 id="生命周期函数" tabindex="-1"><a class="header-anchor" href="#生命周期函数" aria-hidden="true">#</a> 生命周期函数</h2><p>也称为<strong>生命周期钩子</strong>，是 Vue 提供的<strong>内置函数</strong>，会伴随着 Vue 实例的生命周期，<strong>自动</strong>按次序执行，强调的是一个<strong>时间点</strong></p><h3 id="函数种类" tabindex="-1"><a class="header-anchor" href="#函数种类" aria-hidden="true">#</a> 函数种类</h3><p>每个 Vue 实例在被创建时都要经过一系列的<strong>初始化</strong>过程，例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等</p><p>与此同时，Vue 会在 Vue 实例创建、运行、销毁各阶段执行不同的<strong>生命周期钩子</strong>，使得开发者可在不同阶段针对需求调用不同的生命周期钩子</p><p>Vue2 组件的生命周期中，可调用的 <strong>8</strong> 个生命周期钩子：</p><figure><img src="'+s+`" alt="Vue2生命周期钩子" tabindex="0" loading="lazy"><figcaption>Vue2生命周期钩子</figcaption></figure><h3 id="函数使用" tabindex="-1"><a class="header-anchor" href="#函数使用" aria-hidden="true">#</a> 函数使用</h3><p>在 Vue2 中，生命周期钩子是直接作为<strong>选项</strong>被调用，即与 <code>data</code> 选项平级，函数内部的 <code>this</code> 指向调用它的 Vue 实例/组件实例</p><div class="language-vue line-numbers-mode" data-ext="vue"><pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token function-variable function">created</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// this指向当前组件实例</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>

  <span class="token comment">// ES6对象方法简写形式</span>
  <span class="token function">created</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// this指向当前组件实例</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,10),V={class:"hint-container tip"},x=e("p",{class:"hint-container-title"},"Tips",-1),k=a("<li><p>无论开发者是否有调用，所有生命周期钩子都会按组件生命周期的顺序<strong>自动被执行</strong></p></li><li><p>生命周期钩子，或所有<strong>函数形式</strong>的选项式 API，<strong>不能</strong>使用<strong>箭头函数</strong>，因为它内部没有 <code>this</code> 对象，若在箭头函数中使用 <code>this</code>，它将作为变量一直向<strong>上级词法作用域</strong>查找直至找到为止，否则可能会报<code>无法读取 undefined 的属性</code>等错误</p></li>",2),M={href:"https://v2.cn.vuejs.org/v2/api/#%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F",target:"_blank",rel:"noopener noreferrer"},E=e("h2",{id:"详解生命周期",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#详解生命周期","aria-hidden":"true"},"#"),n(" 详解生命周期")],-1),y=e("p",null,[n("在了解完生命周期钩子后，接下来将以一个组件实例的"),e("strong",null,"创建、运行、销毁"),n("的过程（在内存中很快完成），详细分析 Vue2 的 "),e("strong",null,"Vue 实例生命周期"),n("（一个组件实例"),e("strong",null,"本质"),n("上是一个拥有预定义选项的 Vue 实例）")],-1),D={class:"hint-container tip"},T=e("p",{class:"hint-container-title"},"Tips",-1),B={href:"https://baike.baidu.com/item/%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E5%9B%BE/8996271?fr=aladdin",target:"_blank",rel:"noopener noreferrer"},L=e("strong",null,"箭头",-1),O=e("strong",null,"矩形",-1),A=e("strong",null,"菱形",-1),H=a('<h3 id="一、组件创建阶段" tabindex="-1"><a class="header-anchor" href="#一、组件创建阶段" aria-hidden="true">#</a> 一、组件创建阶段</h3><h4 id="_1-new-vue" tabindex="-1"><a class="header-anchor" href="#_1-new-vue" aria-hidden="true">#</a> 1. new Vue()</h4><p>该步骤旨在<strong>创建一个 Vue 实例</strong>，在不同情况下，创建 Vue 实例有着不同的方法：</p><ul><li><p>在 <code>Vue.js</code> 最基础的用法中，是直接在 HTML 文件中，通过 <code>new</code> 关键字来调用 <code>Vue.js</code> 提供的 <strong>Vue 构造函数</strong>以创建 Vue 实例，然后使用 Vue 提供的<code>选项式 API</code>来协助渲染当前 HTML 文件的结构、行为、样式<br> 此用法并未涉及到组件系统，但<strong>本质</strong>上已经在使用组件来定义页面 UI 结构，组件在该用法中是通过包含 Vue <code>选项式 API</code>的 <code>JavaScript 对象</code>来定义的，并未使用 <code>.vue</code> 文件</p></li><li><p>在 Vue 项目或使用构建工具中，则是使用 <code>.vue</code> 文件来定义组件<br> Vue 项目接入<strong>组件系统</strong>：在 <code>main.js</code> 中创建 Vue 实例并设置 DOM 挂载点后，通过渲染函数解析 <code>.vue</code> 文件：</p><ul><li>将页面<strong>结构</strong>交由组件 <code>template</code> 标签定义</li><li>页面<strong>行为</strong>交由组件 <code>script</code> 标签定义</li><li>页面<strong>样式</strong>由组件 <code>style</code> 标签定义</li></ul><p>通过组件嵌套进一步完善页面的 UI 结构，此时原本的 HTML 文件更像是组件系统的<strong>出口文件</strong>，而<strong>根组件</strong>则是其他组件的<strong>入口文件</strong></p></li></ul><p><code>.vue</code> 文件可近似理解为<strong>构造函数</strong>，在通过<strong>标签形式</strong>使用组件时，相当于 <code>new</code> 构造函数以创建一个组件实例</p><h4 id="_2-init-events-lifecycle" tabindex="-1"><a class="header-anchor" href="#_2-init-events-lifecycle" aria-hidden="true">#</a> 2. Init Events &amp; Lifecycle</h4><p>在创建出 Vue 实例后，Vue 就会在内存中<strong>初始化</strong>此组件实例的事件以及生命周期函数</p><h4 id="_3-beforecreate" tabindex="-1"><a class="header-anchor" href="#_3-beforecreate" aria-hidden="true">#</a> 3. beforeCreate</h4><p>当上一步事件与生命周期函数初始化完成后，<code>beforeCreate</code> 函数就会被自动执行</p><div class="hint-container info"><p class="hint-container-title">阶段状态</p><p>此阶段组件实例的 <code>props/data/methods</code> 都<strong>尚未创建</strong>，处于<strong>不可用</strong>状态，因此 <code>beforeCreate</code> 函数在实际开发中用处不大</p></div><h4 id="_4-init-injections-reactivity" tabindex="-1"><a class="header-anchor" href="#_4-init-injections-reactivity" aria-hidden="true">#</a> 4. Init Injections &amp; Reactivity</h4><p><code>beforeCreate</code> 函数执行完毕后，开始初始化组件实例的 <code>props/data/methods</code></p><h4 id="_5-created" tabindex="-1"><a class="header-anchor" href="#_5-created" aria-hidden="true">#</a> 5. created</h4><p>当上一步组件实例的注入与校验初始化完成后，<code>created</code> 函数就会被自动执行</p><div class="hint-container info"><p class="hint-container-title">阶段状态</p><ol><li>组件实例的 <code>props/data/methods</code> 均已<strong>创建好</strong>，处于<strong>可用</strong>状态</li><li>组件实例的模板结构 <code>template</code> <strong>尚未生成</strong></li><li><code>created</code> 函数十分重要，它是生命周期中最早能发起 Ajax 请求的函数</li></ol></div><h4 id="_6-编译-html-结构" tabindex="-1"><a class="header-anchor" href="#_6-编译-html-结构" aria-hidden="true">#</a> 6. 编译 HTML 结构</h4><p><code>created</code> 函数执行完毕后，则需要开始编译 HTML 结构，需按顺序进行一系列的<strong>条件判断</strong>：</p><p><strong>（1）判断 <code>el</code> 选项是否存在：</strong></p><blockquote><p><strong>存在</strong>：即 Vue 实例设置了 <code>el</code> 选项，则直接进入下一步：判断 <code>template</code> 选项是否存在<br><strong>不存在</strong>：则等待 Vue 实例 调用 <code>$mount()</code> 方法后，再进入 <code>template</code> 选项判断框，否则将报错</p></blockquote><p><strong>（2）判断 <code>template</code> 选项是否存在：</strong></p><blockquote><p><strong>存在</strong>：将 <code>template</code> 选项定义的模板结构，编译到 <code>render</code> 函数中传入的参数所控制的区域<br><strong>不存在</strong>：Vue 会根据组件实例中的 <code>template</code> 部分编译 <code>el</code> 选项所控制区域的 HTML 结构，此 HTML 结构可称为 <code>outerHTML</code></p></blockquote><div class="hint-container tip"><p class="hint-container-title">outerHTML</p><p>表示外层 HTML，是因为所编译的 HTML 来源于组件的 <code>template</code>，而不是 <code>el</code> 选项所控制区域内部本身的 HTML 结构</p></div><p><strong>（3）开始编译</strong></p><p>当执行完上两步的判断后，开始基于数据和模板，在内存中编译生成页面的 HTML 结构，编译的工作由依赖包中的 <code>vue-template-compiler</code> 完成</p><h4 id="_7-beforemount" tabindex="-1"><a class="header-anchor" href="#_7-beforemount" aria-hidden="true">#</a> 7. beforeMount</h4><p>当页面 HTML 结构编译完成后，<code>beforeMount</code> 函数就会被自动执行</p><div class="hint-container info"><p class="hint-container-title">阶段状态</p><ol><li>内存中已编译好 HTML 结构，但<strong>未渲染</strong>到浏览器中，此时浏览器中还没有当前组件的 DOM 结构</li><li>此生命周期钩子同样可以发起 Ajax 请求，但在 <code>created</code> 函数中能更早地拿到数据，因此它在实际开发中用处不大</li></ol></div><h4 id="_8-创建-vm-el-并替换-el-选项" tabindex="-1"><a class="header-anchor" href="#_8-创建-vm-el-并替换-el-选项" aria-hidden="true">#</a> 8. 创建 vm.$el 并替换 el 选项</h4><p>当 <code>beforeMount</code> 函数执行完毕后，紧接着：</p><p>（1）用内存中编译生成的 HTML 结构，<strong>替换</strong>掉 <code>el</code> 选项指定的 DOM 元素<br> （2）同时创建 Vue 实例属性 <code>vm.$el</code>，表示 Vue 实例使用的<strong>根 DOM 元素</strong></p><div class="hint-container info"><p class="hint-container-title">阶段状态</p><p>此执行框结束后，组件中的 DOM 结构就<strong>已经被渲染到浏览器</strong>中</p></div><h4 id="_9-mounted" tabindex="-1"><a class="header-anchor" href="#_9-mounted" aria-hidden="true">#</a> 9. mounted</h4><p>当 <code>el</code> 选项指定的 DOM 被组件模板结构替换且 <code>vm.$el</code> 创建后，<code>mounted</code> 函数就会被自动执行</p><div class="hint-container info"><p class="hint-container-title">阶段状态</p><p>此时浏览器已包含了当前组件的 DOM 结构，该生命周期钩子是<strong>最早可操作</strong>到组件中的 DOM 元素的，在实际开发中<strong>十分重要</strong></p></div><h4 id="_10-mounted" tabindex="-1"><a class="header-anchor" href="#_10-mounted" aria-hidden="true">#</a> 10. Mounted</h4><p>进入 Mounted 阶段，表示组件实例已挂载完毕，已成功创建并渲染到浏览器中</p><h4 id="小结-组件创建阶段图解" tabindex="-1"><a class="header-anchor" href="#小结-组件创建阶段图解" aria-hidden="true">#</a> <strong>小结</strong>：组件创建阶段图解</h4><figure><img src="'+r+'" alt="Vue2组件创建阶段" tabindex="0" loading="lazy"><figcaption>Vue2组件创建阶段</figcaption></figure><h3 id="二、组件运行阶段" tabindex="-1"><a class="header-anchor" href="#二、组件运行阶段" aria-hidden="true">#</a> 二、组件运行阶段</h3><p>组件在内存中的创建阶段结束后，就进入组件的<strong>运行阶段</strong>：</p><h4 id="_1-beforeupdate" tabindex="-1"><a class="header-anchor" href="#_1-beforeupdate" aria-hidden="true">#</a> 1. beforeUpdate</h4><p>当组件实例中的任何数据（如 <code>data</code> 选项、<code>computed</code> 选项）发生变化时，<code>beforeUpdate</code> 函数就会被自动执行</p><div class="hint-container info"><p class="hint-container-title">阶段状态</p><p>此阶段的数据已被更新，但相应的 DOM 结构<strong>未重新渲染</strong></p></div><h4 id="_2-重新渲染虚拟-dom" tabindex="-1"><a class="header-anchor" href="#_2-重新渲染虚拟-dom" aria-hidden="true">#</a> 2. 重新渲染虚拟 DOM</h4><p>当 <code>beforeUpdate</code> 生命周期钩子执行完毕后，将根据最新的数据，重新渲染组件的<strong>虚拟 DOM</strong>，并将更新应用到真实的 DOM 中</p><h4 id="_3-updated" tabindex="-1"><a class="header-anchor" href="#_3-updated" aria-hidden="true">#</a> 3. updated</h4><p>当 DOM 重新渲染完毕后，<code>updated</code> 函数就会被自动执行</p><p>此阶段表示 Vue 已根据最新的数据，<strong>完成</strong>了组件 DOM 结构的重新渲染</p>',48),j={class:"hint-container tip"},I=e("p",{class:"hint-container-title"},"操作最新 DOM",-1),C=e("code",null,"updated",-1),$=e("strong",null,"都会被执行一次",-1),w=e("br",null,null,-1),F=e("code",null,"vm.$nextTick()",-1),z={href:"https://v2.cn.vuejs.org/v2/api/#vm-nextTick",target:"_blank",rel:"noopener noreferrer"},N=a('<h4 id="_4-mounted" tabindex="-1"><a class="header-anchor" href="#_4-mounted" aria-hidden="true">#</a> 4. Mounted</h4><p>更新完毕后再次进入 <code>Mounted</code> 阶段，等待下一次数据更新或进行销毁</p><h4 id="小结" tabindex="-1"><a class="header-anchor" href="#小结" aria-hidden="true">#</a> <strong>小结</strong>：</h4><p>整个<strong>重渲染</strong>过程<strong>最少</strong>执行 0 次，即数据一直没有发生任何变化，<strong>最多</strong>执行<strong>无限次</strong></p><p>组件运行阶段图解：</p><figure><img src="'+d+'" alt="Vue2组件运行阶段" tabindex="0" loading="lazy"><figcaption>Vue2组件运行阶段</figcaption></figure><h3 id="三、组件销毁阶段" tabindex="-1"><a class="header-anchor" href="#三、组件销毁阶段" aria-hidden="true">#</a> 三、组件销毁阶段</h3><p>当调用了实例方法 <code>vm.$destroy()</code> 方法后，将进入组件销毁阶段：</p><h4 id="_1-beforedestroy" tabindex="-1"><a class="header-anchor" href="#_1-beforedestroy" aria-hidden="true">#</a> 1. beforeDestroy</h4><p>调用实例方法 <code>vm.$destroy()</code> 后，<code>beforeDestroy</code> 函数就会被自动执行，此时尚未销毁组件，组件还处于<strong>正常工作</strong>状态</p><h4 id="_2-销毁组件" tabindex="-1"><a class="header-anchor" href="#_2-销毁组件" aria-hidden="true">#</a> 2. 销毁组件</h4><p>当 <code>beforeDestroy</code> 函数执行完毕后，将真正进入组件销毁阶段：</p><p>销毁组件的<strong>侦听器</strong>，<strong>子组件</strong>以及<strong>事件监听函数</strong></p><h4 id="_3-destroyed" tabindex="-1"><a class="header-anchor" href="#_3-destroyed" aria-hidden="true">#</a> 3. Destroyed</h4><p>此阶段表示组件已被销毁，此组件在浏览器中对应的 DOM 结构已被<strong>完全移除</strong></p><h4 id="_4-destroyed" tabindex="-1"><a class="header-anchor" href="#_4-destroyed" aria-hidden="true">#</a> 4. destroyed</h4><p>当组件完全销毁后，<code>destroyed</code> 函数就会被自动执行</p><h4 id="小结-组件销毁阶段图解" tabindex="-1"><a class="header-anchor" href="#小结-组件销毁阶段图解" aria-hidden="true">#</a> <strong>小结</strong>：组件销毁阶段图解</h4><figure><img src="'+i+'" alt="Vue2组件销毁阶段" tabindex="0" loading="lazy"><figcaption>Vue2组件销毁阶段</figcaption></figure><h3 id="四、完整图解" tabindex="-1"><a class="header-anchor" href="#四、完整图解" aria-hidden="true">#</a> 四、完整图解</h3><figure><img src="'+c+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p><strong>生命周期</strong>强调的是<strong>时间段</strong>，<strong>生命周期函数</strong>强调的是<strong>时间点</strong></p><p>整个生命周期中，最重要的是 <code>created</code>、<code>mounted</code>、<code>updated</code> 3 个函数</p><h2 id="参考" tabindex="-1"><a class="header-anchor" href="#参考" aria-hidden="true">#</a> 参考</h2>',25),U={href:"https://v2.cn.vuejs.org/v2/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA",target:"_blank",rel:"noopener noreferrer"},q=e("br",null,null,-1),P={href:"https://v2.cn.vuejs.org/v2/api/#%E9%80%89%E9%A1%B9-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90",target:"_blank",rel:"noopener noreferrer"};function S(J,R){const t=g("ExternalLinkIcon");return p(),h("div",null,[f,b,v,u(" more "),m,e("div",V,[x,e("ol",null,[k,e("li",null,[e("p",null,[n("Vue2 还提供了 4 个与生命周期相关的实例方法，参考 "),e("a",M,[n("Vue2 官方 API"),o(t)])])])])]),E,y,e("div",D,[T,e("p",null,[n("生命周期图示类似于"),e("a",B,[n("程序流程图"),o(t)]),n("，其中"),L,n("表示控制流，"),O,n("表示加工步骤（起始框、执行框），"),A,n("表示逻辑条件（判断框）")])]),H,e("div",j,[I,e("p",null,[n("当数据变化后，为了能够操作到最新的 DOM 结构，将逻辑代码写到 "),C,n(" 函数虽是可行的，但该生命周期钩子会在每次数据变化时"),$,w,n(" 作为补充，Vue 提供了实例方法 "),F,n(" ，它表示将在 DOM 更新完毕后调用回调，参考 "),e("a",z,[n("vm.$nextTick"),o(t)])])]),N,e("p",null,[e("a",U,[n("Vue2 生命周期"),o(t)]),q,e("a",P,[n("Vue2 生命周期钩子"),o(t)])])])}const Y=l(_,[["render",S],["__file","详解Vue2组件生命周期.html.vue"]]);export{Y as default};
